// kb: crkbd
// km: neoncorneghost

#include QMK_KEYBOARD_H

// Layer indexes for this keymap. Each symbolic name maps to a numeric layer
// index used by QMK. Use these names with layer_on/layer_off and
// layer_state_is to check or change the active layer.
enum corne_layers {
    _BASE,
    _LOWER,
    _RAISE,
    _TUNE
};

// Custom keycodes specific to this keymap. We start at SAFE_RANGE so we
// don't conflict with existing QMK keycodes. These are handled in
// process_record_user() below to implement custom behaviors (layer toggles,
// multi-key macros, etc.).
enum custom_keycodes {
    LOWER = SAFE_RANGE,
    RAISE,
    QUOTE,
    CIRC,
    WAVE,
    VERTICALBAR,
    GRAVE,
    HUI,
    HUD
};

enum td_keycodes {
    CAPLOCK,
    SUPER,
    ALT
};

// Tap Dance actions. Tap Dance lets a single physical key perform different
// actions depending on how many times it is tapped in quick succession.
// The mapping below defines three tap-dance behaviors used in the keymap:
// - CAPLOCK:  single tap -> Left Shift, double tap -> Caps Lock
// - SUPER:    single tap -> Application/Menu key, double tap -> activate LOWER layer
// - ALT:      single tap -> Right Alt, double tap -> Left Alt
qk_tap_dance_action_t tap_dance_actions[] = {
    [CAPLOCK] = ACTION_TAP_DANCE_DOUBLE(KC_LSFT, KC_CAPS),
    [SUPER] = ACTION_TAP_DANCE_DOUBLE(KC_APPLICATION, LOWER),
    [ALT] = ACTION_TAP_DANCE_DOUBLE(KC_RALT, KC_LALT)
};

// Keymap definition. Each entry here defines the key layout for a layer.
// The LAYOUT_split_3x6_3 macro arranges keycodes according to the physical
// matrix of the Corne/Crkbd board. Read these rows as the physical rows of
// the keyboard; special keycodes (like LOWER, RAISE, custom keycodes and
// tap-dance TD(...)) are handled elsewhere in this file.
const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
    [_BASE] = LAYOUT_split_3x6_3(
        KC_ESCAPE     , KC_Q  , KC_W   , KC_E   , KC_R  , KC_T    , KC_Y , KC_U , KC_I    , KC_O   , KC_P    , KC_BSPC ,
        KC_TAB        , KC_A  , KC_S   , KC_D   , KC_F  , KC_G    , KC_H , KC_J , KC_K    , KC_L   , KC_SCLN , QUOTE   ,
        KC_LEFT_SHIFT , KC_Z  , KC_X   , KC_C   , KC_V  , KC_B    , KC_N , KC_M , KC_COMM , KC_DOT , KC_SLSH , KC_ESC  ,
        KC_LEFT_CTRL  , SUPER , KC_SPC , KC_ENT , RAISE , TD(ALT)
    ),

    [_LOWER] = LAYOUT_split_3x6_3(
        KC_TAB  , KC_1    , KC_2    , KC_3       , KC_4    , KC_5    , KC_6    , KC_7    , KC_8    , KC_9  , KC_0     , KC_BSPC ,
        KC_LSFT , KC_PGDN , KC_PGUP , KC_PSCREEN , KC_LGUI , XXXXXXX , KC_HOME , KC_LEFT , KC_DOWN , KC_UP , KC_RIGHT , KC_END  ,
        KC_LCTL , KC_F1   , KC_F2   , KC_F3      , KC_F4   , KC_F5   , KC_F6   , KC_F7   , KC_F8   , KC_F9 , KC_F10   , KC_F11  ,
        KC_DEL  , _______ , KC_SPC  , KC_ENT     , RAISE   , TD(ALT)
    ),

    [_RAISE] = LAYOUT_split_3x6_3(
        KC_TAB  , KC_EXLM    , KC_AT         , KC_HASH , KC_DLR      , KC_PERC , CIRC     , KC_AMPR , KC_ASTR , KC_LPRN , KC_RPRN     , KC_BSPC ,
        KC_LSFT , KC_LBRC    , KC_RBRC       , KC_LCBR , KC_RCBR     , KC_BSLS , KC_EQUAL , KC_PLUS , KC_MINS , KC_ASTR , KC_KP_SLASH , KC_UNDS ,
        KC_LCTL , RALT(KC_1) , RALT(KC_SLSH) , WAVE    , VERTICALBAR , GRAVE   , XXXXXXX  , XXXXXXX , XXXXXXX , XXXXXXX , XXXXXXX     , XXXXXXX ,
        KC_DEL  , LOWER      , KC_SPC        , KC_ENT  , _______     , TD(ALT)
    ),

    [_TUNE] = LAYOUT_split_3x6_3(
        XXXXXXX , RGB_M_P , RGB_M_B , RGB_M_R , RGB_M_SW , XXXXXXX , XXXXXXX , XXXXXXX , XXXXXXX , XXXXXXX , XXXXXXX , XXXXXXX ,
        RGB_TOG , HUI     , XXXXXXX , XXXXXXX , XXXXXXX  , XXXXXXX , XXXXXXX , XXXXXXX , XXXXXXX , XXXXXXX , XXXXXXX , XXXXXXX ,
        XXXXXXX , HUD     , XXXXXXX , XXXXXXX , XXXXXXX  , XXXXXXX , XXXXXXX , XXXXXXX , XXXXXXX , XXXXXXX , XXXXXXX , XXXXXXX ,
        KC_DEL  , _______ , KC_SPC  , KC_ENT  , _______  , TD(ALT)
    )
};

// ---------------------- variables -----------------------------

#define ANIM_SIZE_GHOST 128 // number of bytes per ghost animation frame (stored in PROGMEM)
#define ANIM_FRAME_DURATION 200 // milliseconds to show each animation frame

led_t led_usb_state;

uint32_t anim_ghost_timer;
uint32_t anim_ghost_sleep;
uint32_t anim_fishing_timer;
uint32_t anim_fishing_sleep;

uint8_t current_wpm = 0;
uint8_t current_ghost_frame = 0;
uint8_t hue_value;
uint8_t sat_value;
uint8_t val_value;
uint8_t mode_value;
uint8_t current_hue;
uint8_t current_val;

char hue_str[4];
char sat_str[4];
char val_str[4];
char mode_str[4];
char wpm_str[4];

// --------------------------------------------------------------

// Runs once right after the keyboard finishes initializing. Use this to
// read initial hardware state and initialize runtime variables that depend
// on that state. Here we capture the current RGB hue and set the working
// brightness limit.
void keyboard_post_init_user(void) {
    current_hue = rgblight_get_hue();
    // Use the configured brightness limit so we don't exceed it later.
    current_val = RGBLIGHT_LIMIT_VAL;
}

// layer_state_set_user is a QMK hook called whenever the layer state
// changes. The "highest" active layer (the one with highest index that is
// currently enabled) is used to decide the RGB color. We avoid changing
// RGB when Caps Lock is on because led_set_user() forces a Caps Lock
// indicator color separately.
layer_state_t layer_state_set_user(layer_state_t state) {

    switch (get_highest_layer(state)) {
        case _TUNE:
            // TUNE layer uses a white RGB for clarity.
            if (!host_keyboard_led_state().caps_lock) {
                rgblight_sethsv(HSV_WHITE);
            }
            break;
        case _RAISE:
            // RAISE layer uses a bluish tint.
            if (!host_keyboard_led_state().caps_lock) {
                rgblight_sethsv(245, 255, current_val);
            }
            break;
        case _LOWER:
            // LOWER layer uses teal.
            if (!host_keyboard_led_state().caps_lock) {
                rgblight_sethsv(HSV_TEAL);
            }
            break;
        case _BASE:
            // BASE layer uses the user's selected hue.
            if (!host_keyboard_led_state().caps_lock) {
                rgblight_sethsv(current_hue, 255, current_val);
            }
            break;
    }
    return state;
}

void led_set_user(uint8_t usb_led) {
    if (usb_led & (1<<USB_LED_CAPS_LOCK)) {
        rgblight_sethsv(22, 255, current_val); // yellow for Caps Lock
    } else { 
        rgblight_sethsv(current_hue, 255, current_val);
    }
}

#ifdef OLED_ENABLE // only compile OLED code if OLED is enabled in rules.mk
#include <stdio.h>
/*
 * Master OLED rendering and ghost animations
 * -----------------------------------------
 * The master_render_ghost() function defines several small bitmap animations
 * (stored in PROGMEM to save RAM) and contains the logic to select which
 * animation to draw on the master half's OLED. Animations are stored as
 * arrays of bytes (bitmaps) and written directly to the OLED with
 * oled_write_raw_P().
 *
 * Selection logic (in animate_ghost):
 * - If Caps Lock is active: show the "hide" animation
 * - If LOWER layer is active: show "shyguy" (or "laugh" when TUNE is also active)
 * - If RAISE layer is active: show "eerie" (or "laugh" when TUNE is also active)
 * - If Left or Right Shift is held: show "scare"
 * - If Right Alt is held: show "troll"
 * - Otherwise: show the default "laugh" animation
 *
 * Timing: an anim_ghost_timer controls the frame rate (ANIM_FRAME_DURATION
 * ms per frame). When the user is typing (non-zero WPM) the animation sleep
 * timers are reset so the display remains active.
 */
static void master_render_ghost(void) {
    static const char PROGMEM hide[2][ANIM_SIZE_GHOST] = { // frames for "hide" animation
        { // 'hide1' 32x28px
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0x40, 0x40, 0x20, 0x20,
            0x20, 0x20, 0x20, 0x20, 0x40, 0x40, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x60, 0x90, 0x08, 0x04, 0x02, 0x01, 0x00, 0x40, 0x20, 0x10, 0x08, 0x08,
            0x08, 0x08, 0x88, 0x70, 0x00, 0x70, 0x88, 0x08, 0x09, 0x12, 0x04, 0x18, 0xe0, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x66, 0x99, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
            0x22, 0x11, 0x08, 0x08, 0x08, 0x08, 0x10, 0x21, 0x02, 0x00, 0x00, 0xc0, 0x3f, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x10, 0x20, 0x20, 0x20, 0x40,
            0x40, 0x40, 0x40, 0x40, 0x20, 0x20, 0x10, 0x10, 0x08, 0x04, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00
        },
        { // 'hide2' 32x28px
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0x40, 0x40, 0x20, 0x20,
            0x20, 0x20, 0x20, 0x20, 0x40, 0x40, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x60, 0x90, 0x08, 0x04, 0x02, 0x01, 0x00, 0x40, 0x20, 0x10, 0x08, 0x08,
            0x08, 0x08, 0x88, 0x70, 0x00, 0x70, 0x88, 0x08, 0x09, 0x12, 0x04, 0x18, 0xe0, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x66, 0x99, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
            0x62, 0x31, 0x38, 0x38, 0x38, 0x38, 0x30, 0x61, 0x82, 0x00, 0x00, 0xc0, 0x3f, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x10, 0x20, 0x20, 0x20, 0x40,
            0x40, 0x40, 0x40, 0x40, 0x20, 0x20, 0x10, 0x10, 0x08, 0x04, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00
        }
    }; 

    static const char PROGMEM shyguy[2][ANIM_SIZE_GHOST] = { // frames for "shyguy" animation
        { // 'shyguy1' 32x28px
            0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0x40, 0x40, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
            0xa0, 0x60, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x40, 0x40, 0x80, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x04, 0x04, 0xfc, 0x44, 0x44, 0x44, 0x44, 0xfe,
            0x01, 0x00, 0x00, 0x1e, 0x1e, 0x1e, 0x00, 0x00, 0x1e, 0x1e, 0x1e, 0x00, 0x01, 0xfe, 0x00, 0x00,
            0x00, 0x70, 0x90, 0x10, 0x10, 0x10, 0x10, 0x08, 0x04, 0x02, 0x01, 0x80, 0x80, 0x00, 0x00, 0x0f,
            0x10, 0x20, 0xc0, 0x40, 0x80, 0x80, 0x98, 0x98, 0x80, 0x80, 0xc0, 0x20, 0x30, 0xcf, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x03, 0x04, 0x08, 0x10, 0x20, 0x20, 0x20, 0x10, 0x08, 0x10, 0x21, 0x42, 0x44,
            0x48, 0x48, 0x47, 0x40, 0x40, 0x40, 0x40, 0x20, 0x20, 0x20, 0x1f, 0x04, 0x08, 0x0f, 0x00, 0x00
        },
        { // 'shyguy2' 32x28px
            0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0x40, 0x40, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
            0xa0, 0x60, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x40, 0x40, 0x80, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x81, 0x02, 0x04, 0x04, 0xfc, 0x44, 0x44, 0x44, 0x44, 0xfe,
            0x01, 0x00, 0x00, 0x1e, 0x1e, 0x1e, 0x00, 0x00, 0x1e, 0x1e, 0x1e, 0x00, 0x01, 0xfe, 0x00, 0x00,
            0x00, 0x38, 0x24, 0x22, 0x21, 0xc0, 0x00, 0x01, 0x02, 0x02, 0x03, 0x80, 0x80, 0x00, 0x00, 0x0f,
            0x10, 0x20, 0xc0, 0x40, 0x80, 0x80, 0x98, 0x98, 0x80, 0x80, 0xc0, 0x20, 0x30, 0xcf, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x06, 0x08, 0x10, 0x10, 0x10, 0x10, 0x10, 0x21, 0x42, 0x44,
            0x48, 0x48, 0x47, 0x40, 0x40, 0x40, 0x40, 0x20, 0x20, 0x20, 0x1f, 0x04, 0x08, 0x0f, 0x00, 0x00
        }
    };

    static const char PROGMEM eerie[2][ANIM_SIZE_GHOST] = { // frames for "eerie" animation
        { // 'eerie1' 32x28px
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0x40, 0x80, 0x00, 0x80, 0x40, 0x20, 0x20, 0x20,
            0x20, 0x40, 0x80, 0x40, 0x20, 0x20, 0x20, 0x20, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x80, 0x4f, 0x50, 0xf0, 0x10, 0x08, 0x07, 0x18, 0x20, 0x40, 0x84, 0x84,
            0x84, 0x40, 0x20, 0x10, 0x14, 0x14, 0x14, 0x10, 0x10, 0x0f, 0x08, 0x08, 0x10, 0xe0, 0x00, 0x00,
            0x00, 0x00, 0x80, 0x87, 0x48, 0x50, 0x50, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x10,
            0x20, 0x28, 0x28, 0xca, 0x02, 0x02, 0x02, 0x02, 0x02, 0xfe, 0x12, 0x12, 0x22, 0xc3, 0x00, 0x00,
            0x00, 0x00, 0x03, 0x04, 0x08, 0x08, 0x10, 0x10, 0x20, 0x20, 0x40, 0x40, 0x40, 0x42, 0x42, 0x4c,
            0x50, 0x50, 0x50, 0x4f, 0x40, 0x20, 0x10, 0x10, 0x0c, 0x07, 0x08, 0x10, 0x10, 0x0f, 0x00, 0x00
        },
        { // 'eerie2' 32x28px
            0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x80, 0x40, 0x20, 0x20, 0x20, 0x20,
            0x40, 0x80, 0x40, 0x20, 0x20, 0x20, 0x20, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x8f, 0x50, 0x50, 0xe0, 0x00, 0x01, 0x1f, 0x20, 0x40, 0x82, 0x82, 0x82,
            0x40, 0x20, 0x10, 0x12, 0x0a, 0x0a, 0x08, 0x08, 0x0f, 0x08, 0x08, 0x08, 0x08, 0x10, 0xe0, 0x00,
            0x00, 0x00, 0xc0, 0x5f, 0x50, 0x50, 0x50, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x10,
            0x10, 0x20, 0x20, 0x48, 0x8a, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0xff, 0x21, 0xc1, 0x01, 0x00,
            0x00, 0x00, 0x03, 0x04, 0x08, 0x08, 0x10, 0x10, 0x20, 0x20, 0x20, 0x20, 0x42, 0x42, 0x42, 0x44,
            0x48, 0x50, 0x50, 0x48, 0x47, 0x20, 0x10, 0x10, 0x08, 0x04, 0x06, 0x09, 0x08, 0x07, 0x00, 0x00
        }
    };

    static const char PROGMEM scare[2][ANIM_SIZE_GHOST] = { // frames for "scare" animation
        { // 'scare1' 32x28px
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0x40, 0x40, 0x20, 0x20,
            0x20, 0x20, 0x20, 0x20, 0x40, 0x40, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x80, 0x40, 0x20, 0x18, 0x04, 0xc2, 0x21, 0x20, 0x20, 0x60, 0xc0, 0x00, 0x00,
            0x00, 0x00, 0xf8, 0xf8, 0x00, 0x00, 0xf8, 0xf8, 0x01, 0x02, 0x04, 0x18, 0xe0, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x19, 0x66, 0x80, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x03, 0x60, 0x60,
            0x18, 0x18, 0x60, 0x60, 0x18, 0x18, 0x60, 0x60, 0x18, 0x18, 0x00, 0xc0, 0x3f, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x10, 0x20, 0x20, 0x20, 0x40,
            0x40, 0x40, 0x40, 0x40, 0x40, 0x20, 0x20, 0x10, 0x08, 0x04, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00
        },
        { // 'scare2' 32x28px
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0x40, 0x40, 0x20, 0x20,
            0x20, 0x20, 0x20, 0x20, 0x40, 0x40, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x80, 0x40, 0x20, 0x18, 0xc4, 0x22, 0x21, 0x20, 0x20, 0x40, 0x80, 0x00, 0x00,
            0x00, 0x00, 0xf8, 0xf8, 0x00, 0x00, 0xf8, 0xf8, 0x01, 0x02, 0x04, 0x18, 0xe0, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x19, 0x66, 0x80, 0x00, 0x00, 0x03, 0x04, 0x08, 0x00, 0x00, 0x00, 0xc0, 0xc0,
            0x7c, 0x7c, 0xf0, 0xf0, 0x7c, 0x7c, 0xf0, 0xf0, 0x3c, 0x3c, 0x00, 0xc0, 0x3f, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x10, 0x20, 0x20, 0x21, 0x41,
            0x40, 0x40, 0x41, 0x41, 0x40, 0x20, 0x21, 0x11, 0x08, 0x04, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00
        }
    };

    static const char PROGMEM troll[2][ANIM_SIZE_GHOST] = { // frames for "troll" animation
        { // 'troll1' 32x28px
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0x40, 0x40, 0x20, 0x20, 0x20,
            0x20, 0x20, 0x20, 0x20, 0x40, 0x40, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x20, 0xd0, 0x08, 0x04, 0x02, 0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x7c,
            0x7c, 0x44, 0x00, 0x00, 0x88, 0xf8, 0xf8, 0x70, 0x01, 0x02, 0x04, 0x18, 0xe0, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x33, 0x4c, 0x80, 0x1e, 0x21, 0x20, 0x10, 0x00, 0x00, 0x18, 0x1e, 0x3c, 0x78,
            0x78, 0xf8, 0xf8, 0xf8, 0xf8, 0x78, 0x78, 0x3c, 0x0e, 0x00, 0x00, 0xc0, 0x3f, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x10, 0x20, 0x20, 0x40, 0x40,
            0x40, 0x40, 0x40, 0x40, 0x20, 0x20, 0x10, 0x10, 0x08, 0x04, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00
        },
        { // 'troll2' 32x28px
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0x40, 0x40, 0x20, 0x20, 0x20,
            0x20, 0x20, 0x20, 0x20, 0x40, 0x40, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x20, 0xd0, 0x08, 0x84, 0x42, 0x41, 0x40, 0x80, 0x00, 0x00, 0x00, 0x38, 0x7c,
            0x7c, 0x44, 0x00, 0x00, 0x88, 0xf8, 0xf8, 0x70, 0x01, 0x02, 0x04, 0x18, 0xe0, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x33, 0x4c, 0x80, 0x03, 0x04, 0x08, 0x10, 0x00, 0x00, 0x00, 0x06, 0x0c, 0x18,
            0x18, 0x38, 0x38, 0x38, 0x38, 0x38, 0x18, 0x0c, 0x06, 0x00, 0x00, 0xc0, 0x3f, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x10, 0x20, 0x20, 0x40, 0x40,
            0x40, 0x40, 0x40, 0x40, 0x20, 0x20, 0x10, 0x10, 0x08, 0x04, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00
        }
    };

    static const char PROGMEM laugh[2][ANIM_SIZE_GHOST] = { // frames for "laugh" animation
        { // 'laugh1' 32x28px
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0x40, 0x40, 0x20, 0x20,
            0x20, 0x20, 0x20, 0x20, 0x40, 0x40, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x60, 0x90, 0x08, 0x04, 0x02, 0x81, 0x80, 0x80, 0x80, 0x00, 0x00, 0x04,
            0x04, 0x04, 0x04, 0x78, 0x00, 0x00, 0x78, 0x04, 0x05, 0x06, 0x04, 0x18, 0xe0, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x66, 0x99, 0x00, 0x00, 0x0f, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x22,
            0x3c, 0x3c, 0x3c, 0x78, 0x78, 0x78, 0x78, 0x3c, 0x00, 0x00, 0x00, 0xc0, 0x3f, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x10, 0x20, 0x20, 0x20, 0x40,
            0x40, 0x40, 0x40, 0x40, 0x40, 0x20, 0x20, 0x10, 0x08, 0x04, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00
        },
        { // 'laugh2' 32x28px
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0x40, 0x40, 0x20, 0x20,
            0x20, 0x20, 0x20, 0x20, 0x40, 0x40, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x60, 0x90, 0x08, 0x04, 0x02, 0x81, 0x80, 0x80, 0x80, 0x00, 0x00, 0x04,
            0x04, 0x04, 0x04, 0x78, 0x00, 0x00, 0x78, 0x04, 0x05, 0x06, 0x04, 0x18, 0xe0, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x66, 0x99, 0x00, 0x00, 0x0f, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x22,
            0x1c, 0x10, 0x10, 0x20, 0x20, 0x20, 0x20, 0x1c, 0x00, 0x00, 0x00, 0xc0, 0x3f, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x10, 0x20, 0x20, 0x20, 0x40,
            0x40, 0x40, 0x40, 0x40, 0x40, 0x20, 0x20, 0x10, 0x08, 0x04, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00
        }
    };

    void animate_ghost(void) {
        current_ghost_frame = (current_ghost_frame + 1) % 2; // alternate between frame 0 and 1
        if (led_usb_state.caps_lock) { // Caps Lock active -> hiding animation
            oled_write_raw_P(hide[abs(1 - current_ghost_frame)], ANIM_SIZE_GHOST); // hide
        }
        else if (IS_LAYER_ON(_LOWER)) {
            if (IS_LAYER_OFF(_TUNE)) {
                // LOWER layer active, normal shyguy animation
                oled_write_raw_P(shyguy[abs(1 - current_ghost_frame)], ANIM_SIZE_GHOST);
            }
            else {
                // LOWER + TUNE -> laughing animation
                oled_write_raw_P(laugh[abs(1 - current_ghost_frame)], ANIM_SIZE_GHOST);
            }
        }
        else if (IS_LAYER_ON(_RAISE)) {
            if (IS_LAYER_OFF(_TUNE)) {
                // RAISE layer active, eerie animation
                oled_write_raw_P(eerie[abs(1 - current_ghost_frame)], ANIM_SIZE_GHOST);
            }
            else {
                // RAISE + TUNE -> laughing animation
                oled_write_raw_P(laugh[abs(1 - current_ghost_frame)], ANIM_SIZE_GHOST);
            }
        }
        else if ( (keyboard_report->mods & MOD_BIT (KC_LSFT)) || (keyboard_report->mods & MOD_BIT (KC_RSFT)) ) {
            // Shift held -> scare animation
            oled_write_raw_P(scare[abs(1 - current_ghost_frame)], ANIM_SIZE_GHOST);
        }
        else if (keyboard_report->mods & MOD_BIT (KC_RALT)) {
            // Right Alt held -> troll animation
            oled_write_raw_P(troll[abs(1 - current_ghost_frame)], ANIM_SIZE_GHOST);
        }
        else {
            // Default: laughing animation
            oled_write_raw_P(laugh[abs(1 - current_ghost_frame)], ANIM_SIZE_GHOST);
        }
    }
    // Update the animation frame at the configured frame duration.
    if (timer_elapsed32(anim_ghost_timer) > ANIM_FRAME_DURATION) {
        anim_ghost_timer = timer_read32(); // reset the frame timer
        animate_ghost(); // draw the next frame
        if (current_wpm != 0) {
            // If the user is typing, update the "last active" timestamp
            anim_ghost_sleep = timer_read32();
        }
    }
}

// Render the textual layer indicator on the OLED. Each line writes the layer
// name and highlights (inverted text) the currently active layer. The
// function uses layer_state_is() and layer_state flags to decide which name
// to highlight. Keep the output compact so it fits on the small OLED.
static void render_layer(void) {
    oled_write_P(PSTR("RAISE"), layer_state_is(_RAISE) && !layer_state_is(_TUNE));
    oled_write_P(PSTR("BASE\n"), layer_state_is(_BASE));
    oled_write_P(PSTR("LOWER"), layer_state_is(_LOWER) && !layer_state_is(_TUNE));
    oled_write_P(PSTR("TUNE\n"), layer_state_is(_TUNE));
}

static void render_mode(void) {
    mode_str[3] = '\0';
    mode_str[2] = '0' + mode_value % 10;
    mode_str[1] = '0' + ( mode_value /= 10) % 10;
    mode_str[0] = '0' + mode_value / 10;
    // Format the RGB mode number as a 3-digit ASCII string and print it.
    // mode_value comes from rgblight_get_mode(). Note: the code below uses
    // the "/=" operator which mutates mode_value. That works here because
    // mode_value is a copy of the global retrieved earlier in oled_task_user(),
    // but be careful if you refactor this code.
    oled_write("MODE ", false);
    oled_write(" ", false);
    oled_write(mode_str, false);
}

// Print current Hue, Saturation and Value (HSV) to the OLED.
// The function converts numeric HSV values into 3-char ASCII strings for
// compact display. Note: the implementation uses in-place division (x /= 10)
// which mutates the source variable; if you need the original values later
// copy them into a temporary variable first.
static void render_hsv(void) {
    oled_write("H ", false);
    hue_str[3] = '\0';
    hue_str[2] = '0' + hue_value % 10;
    hue_str[1] = '0' + ( hue_value /= 10) % 10;
    hue_str[0] = '0' + hue_value / 10;
    oled_write(hue_str, false);

    oled_write("S ", false);
    sat_str[3] = '\0';
    sat_str[2] = '0' + sat_value % 10;
    sat_str[1] = '0' + ( sat_value /= 10) % 10;
    sat_str[0] = '0' + sat_value / 10;
    oled_write(sat_str, false);

    oled_write("V ", false);
    val_str[3] = '\0';
    val_str[2] = '0' + val_value % 10;
    val_str[1] = '0' + ( val_value /= 10) % 10;
    val_str[0] = '0' + val_value / 10;
    oled_write(val_str, false);    
}

static void slave_render_ghost(void) {
    // The slave (secondary) OLED displays a larger "fishing" animation.
    // This array contains two 416-byte frames (32x100 pixels represented as
    // pages) stored in PROGMEM. The animate_fishing() helper toggles
    // current_ghost_frame and writes the appropriate frame to the slave OLED.
    static const char PROGMEM fishing[2][416] = { // frames for "fishing" animation
        { // 'fishing1' 32x100px
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0x20, 0x10,
            0x10, 0x10, 0x10, 0x10, 0x20, 0x20, 0x20, 0x20, 0x50, 0x88, 0x08, 0x10, 0x28, 0x44, 0xa8, 0x10,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x7c, 0x82, 0x01, 0x61, 0x01, 0x02,
            0x84, 0x48, 0x84, 0x02, 0x61, 0x01, 0x02, 0x84, 0x78, 0x00, 0x03, 0x0c, 0x32, 0xc1, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x08, 0x06, 0x01, 0x08, 0x90, 0x61, 0x02, 0x02, 0x01,
            0x00, 0x00, 0x00, 0x01, 0x82, 0x82, 0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xfe, 0x00,
            0x04, 0x04, 0x02, 0x02, 0x01, 0x01, 0x01, 0x02, 0x0e, 0x11, 0x21, 0x20, 0x20, 0x40, 0x82, 0xff,
            0x02, 0x00, 0x0e, 0x11, 0x20, 0x20, 0x40, 0x01, 0x81, 0x82, 0x42, 0x44, 0x40, 0x20, 0x3f, 0x40,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9f,
            0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x40, 0x40, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f,
            0x00, 0xc0, 0x20, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x03, 0x04, 0x04, 0x08, 0x08, 0x08, 0x04, 0x04, 0x02, 0x02, 0x01, 0xfd,
            0x01, 0x00, 0x00, 0x00, 0x01, 0x02, 0x02, 0x04, 0x04, 0x02, 0x01, 0x02, 0x04, 0x04, 0x08, 0x08,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf9,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x20, 0x30, 0xc0, 0x00, 0xf8, 0x04, 0x02, 0x01, 0x01, 0x31,
            0x49, 0x85, 0x92, 0x68, 0x08, 0x08, 0x10, 0x20, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x7f, 0x80, 0x00, 0x00, 0xc0, 0x81, 0x00, 0xc0, 0xf0, 0xf0, 0xf8, 0x88,
            0x00, 0x20, 0xe0, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x07, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x06, 0x08, 0x10, 0x13, 0x27, 0x4f, 0x5f, 0x5f, 0x5f, 0x5f,
            0x5f, 0x5f, 0x5f, 0x4f, 0x27, 0x13, 0x08, 0x04, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        },
        { // 'fishing2' 32x100px
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0x20, 0x10,
            0x10, 0x10, 0x10, 0x10, 0x20, 0x20, 0x20, 0x20, 0x50, 0x88, 0x08, 0x10, 0x28, 0x44, 0xa8, 0x10,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x7c, 0x82, 0x01, 0x61, 0x01, 0x02,
            0x84, 0x48, 0x84, 0x02, 0x61, 0x01, 0x02, 0x84, 0x78, 0x00, 0x03, 0x0c, 0x32, 0xc1, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x08, 0x06, 0x01, 0x08, 0x90, 0x61, 0x02, 0x02, 0x01,
            0x00, 0x00, 0x00, 0x01, 0x82, 0x82, 0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xfe, 0x00,
            0x04, 0x04, 0x02, 0x02, 0x01, 0x01, 0x01, 0x02, 0x0e, 0x11, 0x21, 0x20, 0x20, 0x40, 0x82, 0xff,
            0x02, 0x00, 0x0e, 0x11, 0x20, 0x20, 0x40, 0x01, 0x81, 0x82, 0x42, 0x44, 0x40, 0x20, 0x3f, 0x40,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9f,
            0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x40, 0x40, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f,
            0x00, 0xc0, 0x20, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x03, 0x04, 0x04, 0x08, 0x08, 0x08, 0x04, 0x04, 0x02, 0x02, 0x01, 0xfd,
            0x01, 0x00, 0x00, 0x00, 0x01, 0x02, 0x02, 0x04, 0x04, 0x02, 0x01, 0x02, 0x04, 0x04, 0x08, 0x08,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0xf9,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x80, 0x40, 0x20, 0x10, 0xd0, 0x30, 0x01, 0x82, 0x64, 0x18, 0x00, 0x00, 0x00,
            0x01, 0x06, 0x18, 0xe0, 0x00, 0x00, 0xc0, 0x30, 0x08, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x3f, 0xc0, 0x00, 0x00, 0x01, 0xc2, 0xe2, 0x21, 0x00, 0x80, 0xc4, 0xfc, 0xf8,
            0xf0, 0xc0, 0x00, 0x00, 0x01, 0xc1, 0xf0, 0x00, 0x00, 0x01, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x06, 0x08, 0x11, 0x13, 0x26, 0x4e, 0x5f, 0x5f, 0x5f, 0x5f,
            0x5f, 0x5f, 0x5e, 0x5e, 0x4f, 0x27, 0x11, 0x08, 0x04, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        }
    };  
    // Toggle and draw the fishing animation on the slave OLED at the
    // configured frame rate. The sleep timer is updated when the user is
    // typing to keep the display active.
    void animate_fishing(void) {
        current_ghost_frame = (current_ghost_frame + 1) % 2; // alternate frames
        oled_write_raw_P(fishing[abs(1 - current_ghost_frame)], 416);
    }
    if (timer_elapsed32(anim_fishing_timer) > ANIM_FRAME_DURATION) {
        anim_fishing_timer = timer_read32();
        animate_fishing();
        if (current_wpm != 0) {
            anim_fishing_sleep = timer_read32();
        }
    }
}

/*
static void render_wpm(void) {
    oled_write("WPM\n", false);
    sprintf(wpm_str, "%03d", current_wpm);
    oled_write(wpm_str, false); // print WPM value
}
*/

// Initialize the OLED rotation for each half. Returning a rotation here
// tells the OLED driver how to orient the display. This board uses the
// same rotation (270 degrees) for both master and slave so the graphics
// align correctly with the physical mounting.
oled_rotation_t oled_init_user(oled_rotation_t rotation) {
    if (is_keyboard_master()) {
        return OLED_ROTATION_270;
    }
    else {
        return OLED_ROTATION_270;
    }
    return rotation;
}

// OLED characteristics: 128x32 pixels. Internally the driver operates in
// 8-pixel-high pages (so 128/8 = 16 pages across 128 pixels). This task
// is called periodically by QMK and is responsible for drawing content on
// each OLED.
bool oled_task_user(void) {
    current_wpm = get_current_wpm();
    mode_value = rgblight_get_mode();
    hue_value = rgblight_get_hue();
    sat_value = rgblight_get_sat();
    val_value = rgblight_get_val();
    if ((timer_elapsed32(anim_ghost_sleep) > 120000) && (timer_elapsed32(anim_fishing_sleep) > 120000) && (current_wpm == 0)) {
        if (is_oled_on()) {
            oled_off();
        }
        timer_init();
        return true;
    }
    if (current_wpm != 0 && !is_oled_on()) {
        oled_on();
    }
    led_usb_state = host_keyboard_led_state();
    if (is_keyboard_master()) { // master OLED: ghost animation + status
        oled_set_cursor(0,1);
        master_render_ghost(); // ghost animation
        oled_set_cursor(0,6);
        render_layer(); // layer indicators
        oled_set_cursor(0,11);
        render_hsv(); // HSV values
    }
    else { // slave OLED: fishing animation + mode
        oled_set_cursor(0,1);
        slave_render_ghost();
        oled_set_cursor(0,13);
        render_mode();
    }
    return true;
}

#endif // OLED_ENABLE

// process_record_user handles custom keycodes defined earlier (LOWER,
// RAISE, QUOTE, CIRC, WAVE, VERTICALBAR, GRAVE, HUI, HUD) and is called on
// every key event. Return false from a case to indicate that we've handled
// the key and QMK should not perform default processing for it. Typical
// uses here are:
// - Toggle layers (layer_on/layer_off and update_tri_layer for tri-layer)
// - Emit multiple keycodes (register_code/unregister_code) to produce
//   small macros (e.g., quote + space)
// - Adjust runtime variables (e.g., current_hue for RGB
//   control)
bool process_record_user(uint16_t keycode, keyrecord_t *record) {
    switch (keycode) {
        case HUI:
            if (record->event.pressed) {
                current_hue = current_hue + 5;
                if (current_hue > 255) {
                    current_hue = current_hue - 256;
                }
            }
            else {
                ;
            }
            return false;
        case HUD:
            if (record->event.pressed) {
                current_hue = current_hue - 5;
                if (current_hue < 0) {
                    current_hue = 256 + current_hue;
                }
            }
            else {
                ;
            }
            return false;
        case LOWER:
            if (record->event.pressed) {
                layer_on(_LOWER);
                update_tri_layer(_LOWER, _RAISE, _TUNE);
            }
            else {
                layer_off(_LOWER);
                update_tri_layer(_LOWER, _RAISE, _TUNE);
            }
            return false;
        case RAISE:
            if (record->event.pressed) {
                layer_on(_RAISE);
                update_tri_layer(_LOWER, _RAISE, _TUNE);
            }
            else {
                layer_off(_RAISE);
                update_tri_layer(_LOWER, _RAISE, _TUNE);
            }
            return false;
        case QUOTE:
            if (record->event.pressed) {
                register_code(KC_QUOTE);
                register_code(KC_SPACE);
            }
            else { 
                unregister_code(KC_QUOTE);
                unregister_code(KC_SPACE);
            }
            return false;
        case CIRC:
            if (record->event.pressed) {
                register_code(KC_LSFT);
                register_code(KC_6);
                register_code(KC_SPACE);
            }
            else {
                unregister_code(KC_LSFT);
                unregister_code(KC_6);
                unregister_code(KC_SPACE);
            }
            return false;
        case WAVE:
            if (record->event.pressed) {
                register_code(KC_LSFT);
                register_code(KC_GRAVE);
                register_code(KC_SPACE);
            }
            else {
                unregister_code(KC_LSFT);
                unregister_code(KC_GRAVE);
                unregister_code(KC_SPACE);
            }
            return false;
        case VERTICALBAR:
            if (record->event.pressed) {
                register_code(KC_LSFT);
                register_code(KC_BSLASH);
            }
            else {
                unregister_code(KC_LSFT);
                unregister_code(KC_BSLASH);
            }
            return false; 
        case GRAVE:
            if (record->event.pressed) {
                register_code(KC_GRAVE);
                register_code(KC_SPACE);
            }
            else {
                unregister_code(KC_GRAVE);
                unregister_code(KC_SPACE);
            }
            return false;
    }
    return true;
}